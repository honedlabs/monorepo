<?php

declare(strict_types=1);

namespace Honed\Bind;

use Honed\Bind\Attributes\Binds;
use Illuminate\Container\Container;
use Illuminate\Contracts\Foundation\Application;
use Illuminate\Support\Facades\App;
use Illuminate\Support\Str;
use ReflectionClass;
use ReflectionMethod;
use Throwable;

use function array_reduce;

/**
 * @template TModel of \Illuminate\Database\Eloquent\Model = \Illuminate\Database\Eloquent\Model
 */
abstract class Binder
{
    /**
     * The default namespace where binders reside.
     *
     * @var string
     */
    public static $namespace = 'App\\Binders\\';

    /**
     * The name of the binder's corresponding model.
     *
     * @var class-string<TModel>|null
     */
    protected $model;

    /**
     * The key of the binder to be used when resolving the value of the binding.
     *
     * @var string|null
     */
    protected $key;

    /**
     * Store a memory-cache of the binders to ensure that we don't have to re-instantiate them.
     *
     * @var array<class-string<\Illuminate\Database\Eloquent\Model>, array<string, class-string<self>>>|null
     */
    protected static $binders;

    /**
     * The default model name resolvers.
     *
     * @var array<class-string, callable(self): class-string<TModel>>
     */
    protected static $modelNameResolvers = [];

    /**
     * Retrieve the binder for the model which binds the given field if it exists.
     *
     * @param  class-string<TModel>  $model
     * @param  string  $field
     * @return self|null
     */
    public static function for($model, $field)
    {
        return static::cached($model, $field);
    }

    /**
     * Get the binder from the Binds class attribute.
     *
     * @return class-string<\Illuminate\Database\Eloquent\Model>|null
     */
    public static function getBindsAttribute()
    {
        $attributes = (new ReflectionClass(static::class))
            ->getAttributes(Binds::class);

        if ($attributes !== []) {
            $for = $attributes[0]->newInstance();

            return $for->model;
        }

        return null;
    }

    /**
     * Specify the callback that should be invoked to guess model names based on binder names.
     *
     * @param  callable(self): class-string<TModel>  $callback
     * @return void
     */
    public static function guessModelNamesUsing($callback)
    {
        static::$modelNameResolvers[static::class] = $callback;
    }

    /**
     * Specify the default namespace that contains the application's model binders.
     *
     * @param  string  $namespace
     * @return void
     */
    public static function useNamespace($namespace)
    {
        static::$namespace = $namespace;
    }

    /**
     * Flush the binder's global state.
     *
     * @return void
     */
    public static function flushState()
    {
        static::$binders = null;
        static::$modelNameResolvers = [];
        static::$namespace = 'App\\Binders\\';
    }

    /**
     * Resolve the binding for the model.
     *
     * @param  \Illuminate\Database\Eloquent\Model|\Illuminate\Database\Eloquent\Builder<\Illuminate\Database\Eloquent\Model>|\Illuminate\Database\Eloquent\Relations\Relation  $query
     * @param  mixed  $value
     * @param  string  $field
     * @return \Illuminate\Database\Eloquent\Model|null
     */
    public function resolve($query, $value, $field) // @phpstan-ignore missingType.generics
    {
        return $this->query($query, $value, $field)->first();
    }

    /**
     * Resolve the binding query for the model.
     *
     * @param  \Illuminate\Database\Eloquent\Model|\Illuminate\Database\Eloquent\Builder<\Illuminate\Database\Eloquent\Model>|\Illuminate\Database\Eloquent\Relations\Relation  $query
     * @param  mixed  $value
     * @param  string  $field
     * @return \Illuminate\Database\Eloquent\Builder<\Illuminate\Database\Eloquent\Model>
     */
    public function query($query, $value, $field) // @phpstan-ignore missingType.generics
    {
        if (isset($this->key)) {
            $query = $query->where($this->key, $value);
        }

        return $this->{$field}($query, $value);
    }

    /**
     * Get the bindings available on this binder.
     *
     * @return array<int, string>
     */
    public function bindings()
    {
        return array_reduce(
            (new ReflectionClass($this))
                ->getMethods(ReflectionMethod::IS_PUBLIC),

            function (array $bindings, ReflectionMethod $method) {
                if ($this->binds($method)) {
                    $bindings[] = $method->getName();
                }

                return $bindings;
            }, []
        );
    }

    /**
     * Get the name of the model that is generated by the binder.
     *
     * @return class-string<\Illuminate\Database\Eloquent\Model>
     */
    public function modelName()
    {
        if (isset($this->model)) {
            return $this->model;
        }

        if ($model = static::getBindsAttribute()) {
            return $model;
        }

        $resolver = static::$modelNameResolvers[static::class] ?? static::$modelNameResolvers[self::class] ?? function (self $binder) {
            $namespacedBinderBasename = Str::replaceLast(
                'Binder', '', Str::replaceFirst(static::$namespace, '', $binder::class)
            );

            $binderBasename = Str::replaceLast('Binder', '', class_basename($binder));

            $appNamespace = static::appNamespace();

            return class_exists($appNamespace.'Models\\'.$namespacedBinderBasename)
                ? $appNamespace.'Models\\'.$namespacedBinderBasename
                : $appNamespace.$binderBasename;
        };

        /** @var class-string<\Illuminate\Database\Eloquent\Model> */
        return $resolver($this);
    }

    /**
     * Retrieve the binder from the cache.
     *
     * @param  class-string<TModel>  $model
     * @param  string  $field
     * @return self|null
     */
    protected static function cached($model, $field)
    {
        if (! isset(static::$binders)) {
            /** @var array<class-string<\Illuminate\Database\Eloquent\Model>, array<string, class-string<self>>> $binders */
            $binders = require App::getCachedBindersPath();

            static::$binders = $binders;
        }

        if (isset(static::$binders[$model][$field])) {
            $class = static::$binders[$model][$field];

            return App::make($class);
        }

        return null;
    }

    /**
     * Get the application namespace for the application.
     *
     * @return string
     */
    protected static function appNamespace()
    {
        try {
            return Container::getInstance()
                ->make(Application::class)
                ->getNamespace();
        } catch (Throwable) {
            return 'App\\';
        }
    }

    /**
     * Determine if the class method is for binding.
     *
     * @param  ReflectionMethod  $method
     * @return bool
     */
    protected function binds($method)
    {
        return ! $method->isStatic()
            && $method->getDeclaringClass()->getName() === $this::class;
    }
}
